class A {
    public static void staticMethod() {
        System.out.println("Статический метод класса A");
    }
    
    public void instanceMethod() {
        System.out.println("Нестатический метод класса A");
    }
}

class B extends A {
    // Это НЕ переопределение, а сокрытие (method hiding)
    public static void staticMethod() {
        System.out.println("Статический метод класса B");
    }
    
    // Это переопределение (method overriding)
    @Override
    public void instanceMethod() {
        System.out.println("Переопределенный метод класса B");
    }
}

public class StaticPolymorphism {
    public static void main(String[] args) {
        System.out.println("=== Статические методы ===");
        A.staticMethod(); // Статический метод класса A
        B.staticMethod(); // Статический метод класса B
        
        A a = new A();
        A bAsA = new B(); // Ссылка типа A на объект B
        B b = new B();
        
        // Для статических методов выбор происходит по ТИПУ ССЫЛКИ (компиляция)
        a.staticMethod();      // Статический метод класса A (тип ссылки: A)
        bAsA.staticMethod();   // Статический метод класса A (тип ссылки: A) - НЕ полиморфизм!
        b.staticMethod();      // Статический метод класса B (тип ссылки: B)
        
        System.out.println("\n=== Нестатические методы ===");
        // Для нестатических методов выбор происходит по ТИПУ ОБЪЕКТА (выполнение)
        a.instanceMethod();     // Нестатический метод класса A
        bAsA.instanceMethod();  // Переопределенный метод класса B - ДА, полиморфизм!
        b.instanceMethod();     // Переопределенный метод класса B
    }
}

/*
ОБЪЯСНЕНИЕ РЕЗУЛЬТАТОВ:

Почему динамический полиморфизм не применяется к статическим методам:

1. СТАТИЧЕСКИЕ МЕТОДЫ - связывание на этапе КОМПИЛЯЦИИ:
   - Выбор метода определяется ТИПОМ ССЫЛКИ (переменной)
   - bAsA.staticMethod() вызывает A.staticMethod() (несмотря на объект типа B)
   - Это называется "method hiding", а не "method overriding"

2. НЕСТАТИЧЕСКИЕ МЕТОДЫ - связывание на этапе ВЫПОЛНЕНИЯ:
   - Выбор метода определяется ТИПОМ ОБЪЕКТА (экземпляра)
   - bAsA.instanceMethod() вызывает B.instanceMethod() (полиморфизм)

3. ПРИЧИНЫ:
   - Статические методы принадлежат КЛАССУ, а не объекту
   - Нет виртуальной таблицы (vtable) для статических методов
   - Компилятор заменяет вызовы статических методов на прямые ссылки

ВЫВОД: 
Динамический полиморфизм работает только с нестатическими методами,
так как требует информации о реальном типе объекта во время выполнения.
*/